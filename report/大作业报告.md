# 2020数据科学大作业报告

## 1.成员组成
|  姓名   |  负责部分   |
|-----|  -------   |
|   耿艺  |   部分基于提交数据的特征统计和分析         |
|  脱晓彤 |   部分基于提交数据的特征统计与分析       |
|  胡海川 |   基于抽象语法树的代码摘要和相似性分析         |


## 2.研究主题：学生代码提交记录分析——编程能力与习惯评价

### 2.1 基于提交数据的特征统计与分析

#### 2.1.1 概述
根据助教提供的学生提交数据分析学生编程的部分能力和习惯


### 2.2 基于抽象语法树的代码摘要和相似性分析


#### 2.2.1 代码摘要
##### 2.2.1.1特征选取
######  a. 语法树层高(代码复杂度)
######  b.语法树节点数量(代码复杂度)
######  c.类定义代码行数(面向对象/结构化风格)
######  d.节点数量&&层高(代码组织风格)

##### 2.2.1.2代码实现： /utils/tree/mk_summary

##### 2.2.1.3算法缺陷
1. 节点数量和层高的关系需要大量测试代码进行定量计算确定


#### 2.2.2 相似性分析
##### 2.2.2.1 目的
 1. 检测同学之间是否有抄袭，借鉴现象
 2. 检测标准答案与目标代码之间的相似度，作为为评价标准之一
##### 2.2.2.2 同类方法和思考改进
 1. 分析代码相似度的方法有很多，诸如基于生成的特征向量比较法，图相似比较法，基于神经网络的相似度比较法等等，这里采取抽象语法树，是因为语法树更能反应代码的结构信息，即抛开具体实现底层的上层信息。
 2. 叶子节点根据节点的类型和属性生成哈希值，父节点累加子节点的哈希值，并结合自身的属性生成新的哈希值。
 3. 如果单纯静态地比较代码抽象语法树的相似程度，会造成这样的结果：如果抄袭者修改拆分了一些局部变量，会造成它们父节点的哈希值的变化，往往导致误判。在此基础上，通过语法树的剪枝消除底层信息的差异，比较上层信息的相似度，如果发现相似度超过阈值，进行回溯，将删去的节点逐一放回，直到到达阈值的边界。
 4. 根据剪枝回放后剩余节点的个数，与原有节点的个数进行比较，若超过某个比值则可以判定代码涉嫌抄袭
##### 2.2.2.3 测试数据
相似代码数据集：
a. 变量更换名字
b. 表达式拆分
c. 函数拆分
##### 2.2.2.4 算法缺陷
1.  如果语法树结构相差很多，则难以通过同步的剪枝来判断(例如将表达式封装成函数进行调用会提升ast层数)
2.  回放节点的算法有待改进


## 3.代码开源地址
https://github.com/Txtxiao/-
### 3.1 代码结构
master存放原始json数据和数据处理包(处理后的json数据文件和包含画图代码的图包)等
以及dev分支中处理抽象语法树
## 4.研究方法
### 4.1 基于提交数据的特征统计与分析
#### 4.1.1 数据集
起始数据集为助教提供的test_data.json文件，在此基础上依次通过数据处理分离出average.json文件（每道题均分）、score.json（题目id及其分数）、result.json（题目提交次数，最终得分，该题平均得分，第一次提交与最后一次提交间隔时间（单位：分钟））、 average_score.json（每个人平均分） average_class.json文件（每种题型平均分）、type_average.json（每个人每种题型平均分）
#### 4.1.2 数据处理
通过一个或多个数据集，生成更有助于分析多项数值的数据集，通过import json处理原始数据集，从而生成新的需要的数据集。
* 以生成average_score.json为例：
```python
import json
data = json.loads(open('result.json', encoding='utf-8').read()) #打开result.json文件
res = {}
for key in data:
    user = data[key]
    res[key]=0
    for i in user:
        res[key]+=data[key][i]["score"]
    res[key]=res[key]/len(data[key]) #每个人所做题目总分相加/所做题目总数量
filename = 'average_score.json'
with open(filename, 'w', encoding='utf-8') as file_obj:#存入json文件
    json.dump(res, file_obj, ensure_ascii=False, indent=4)
```
#### 4.1.3 生成图
分析文件以“print_”开头，通过画折线图、饼状图、雷达图、散点图等多种方式分析各个部分之间的关系，使用了matplotlib绘图库,以及NumPy和pandas等
* print_relationship: 以题目id为横坐标，纵坐标包括提交次数和分数，生成某学生每道题得分和该题总均分的对比折线图以及该生在某道题上的提交次数。通过折线图的对比可反映该生某道题的水平较整体强弱，亦可结合提交次数整体评判。
* print_type1:在print_class基础上，计算某个学生每种类型的题目的平均分，与该类型的题目的总体平均分作对比，画在雷达图中，可横向纵向分析出该生的弱势及优势。
* print_date：以日期为横坐标，分数为纵坐标，通过绘制散点图可看出某学生在一段时间内的学习效率和状态。
#### 4.1.4 其他工具
* 时间轴转换：将原始数据集中的时间轴转换成标准时间（年月日时分秒）
* 例：
```python
import time,datetime
timeStamp =  1582427860422/1000 #时间轴
timeArray = time.localtime(timeStamp)
otherStyleTime = time.strftime("%Y-%m-%d %H:%M:%S", timeArray)
print(otherStyleTime)   # 2020-02-23 11:17:40
```
## 5.案例分析
* print_average
![](https://gyyy.oss-cn-hangzhou.aliyuncs.com/foundaionsOfDataScience/Figure_1.png)
> 我们统计了全部学生的成绩分布区间，100分110人，95-99有119人，85-95有21人，70-85有9人，70以下12人(其中4人零分)，共计271人。超一半的人作业态度端正能够认真完成，仍有部分同学成绩过低。
* print_relationship
![以3544为例](https://datascience-txt.oss-cn-beijing.aliyuncs.com/print_relationship_3544.png)
> 以user_id为3544的学生为例，该生一共提交8道题，其中3道题分数超过该题均分，除一个异常数据外，其余题目提交次数为1~6次，整体编成水平较弱
* print_type1
![以60587为例](https://datascience-txt.oss-cn-beijing.aliyuncs.com/print_type1_60587.png)
> 以user_id为60587的学生为例，该生8种类型的题目平均分依次为：94.67（字符串）,98.82（查找算法）,89.17（排序算法），87.79（数组），86（线性表），82.22（图结构），69.39（树结构），97（数字操作）。可看出该生在查找算法和数字操作两种类型上处于优势，但较总体水平略有欠缺，有待提高。
* print_date
![以60671为例](https://datascience-txt.oss-cn-beijing.aliyuncs.com/print_date_60671.png)    
> 以user_id为60671的学生为例，该生集中做题的时间为2020-02-17到2020-03-09这段区间内，可看出该生并不是习惯拖ddl的人，前期做题较密集，中后期的部分提交记录可能是由于题目难度过大，思考时间过长造成。做题有时间意识，习惯良好。
* print_habit
![以60898为例](https://gyyy.oss-cn-hangzhou.aliyuncs.com/foundaionsOfDataScience/Figure_2.png)
> 以user_id为60898的学生为例，该生上午没有提交记录，基本在下午两点到六点，偶尔晚上十点也会提交代码，可能没有熬夜的习惯。分数两极分化，零分或者一百分，几乎没有出现频繁提交看报错用例找bug的分数逐步上升的情况，逻辑思维清晰解决报错能力强。
## 6.其他（对czy说的话）


## 7.附录
### 参考文献
1. 《一种改进的基于抽象语法树的软件源代码比对算法》, 中图分类号：TP309, 文献标识码：A, 文章编号 ：1671-1122（2014）01-0038-05  
2.  杨宇霞.编程能力评估模型研究进展[J].现代计算机(专业版),2019(02):33-36+40.
